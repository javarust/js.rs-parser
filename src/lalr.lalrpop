use std::str::FromStr;
use std::f64::NAN;
use ast::{BinOp, Exp, Stmt};

grammar;

// Statement nonterminal
pub Stmt: Stmt = {
    <Var> "=" <Exp>  ";" => Stmt::Assign(<>),
    "var" <Var> "=" <Exp> ";" => Stmt::Decl(<>),
    <Exp> ";" => Stmt::BareExp(<>),
};

// Expression nonterminal
pub Exp: Exp = {
    <e:Exp> <o:AddOp> <m:MulExp> => Exp::BinExp(Box::new(e), o, Box::new(m)),
    MulExp,
};

AddOp: BinOp = {
    "+" => BinOp::Plus,
    "-" => BinOp::Minus,
};

// Parses multiplication
MulExp: Exp = {
    <m:MulExp> <o:MulOp> <e:PreExp> => Exp::BinExp(Box::new(m), o, Box::new(e)),
    PreExp,
};

MulOp: BinOp = {
    "*" => BinOp::Star,
    "/" => BinOp::Slash,
};

PreExp: Exp = {
    "++" <PreExp> => Exp::PreInc(Box::new(<>)),
    "--" <PreExp> => Exp::PreDec(Box::new(<>)),
    PostExp,
};

PostExp: Exp = {
    <PostExp> "++" => Exp::PostInc(Box::new(<>)),
    <PostExp> "--" => Exp::PostDec(Box::new(<>)),
    Term,
};

// Parses numbers and parenthetical expressions, and variables
Term: Exp = {
    Float => Exp::Float(<>),
    Var => Exp::Var(<>),
    "undefined" => Exp::Undefined,
    "(" <Exp> ")",
    "-" <Term> => Exp::Neg(Box::new(<>)),
    "+" <Term> => Exp::Pos(Box::new(<>)),
};

Float: f64 = {
    // '2' or '2.'
    r"-?[0-9]+\.?" => f64::from_str(<>).unwrap(),
    // '.2' or '2.0'
    r"-?[0-9]*\.[0-9]+" => f64::from_str(<>).unwrap(),
    "NaN" => NAN
};

Var: String = {
    r"[A-Za-z_][0-9A-Za-z_]*" => String::from(<>)
};
