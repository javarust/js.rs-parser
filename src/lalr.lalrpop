use std::str::FromStr;
use std::f64::NAN;
use ast::{BinOp, Exp, Stmt};

grammar;

// Statement nonterminal
pub Stmt: Stmt = {
    SingleStmt,
    <s1:SingleStmt> <s2:Stmt> => Stmt::Seq(Box::new(s1), Box::new(s2)),
};

SingleStmt: Stmt = {
    <Var> "=" <Exp> ";" => Stmt::Assign(<>),
    "var" <Var> "=" <Exp> ";" => Stmt::Decl(<>),
    <Exp> ";" => Stmt::BareExp(<>),
};

// Expression nonterminal
pub Exp: Exp = {
    <e:Exp> <o:AddOp> <m:MulExp> => Exp::BinExp(Box::new(e), o, Box::new(m)),
    MulExp,
};

AddOp: BinOp = {
    "+" => BinOp::Plus,
    "-" => BinOp::Minus,
};

// Parses multiplication
MulExp: Exp = {
    <m:MulExp> <o:MulOp> <t:Term> => Exp::BinExp(Box::new(m), o, Box::new(t)),
    Term,
};

MulOp: BinOp = {
    "*" => BinOp::Star,
    "/" => BinOp::Slash,
};

// Parses numbers and parenthetical expressions
Term: Exp = {
    Float => Exp::Float(<>),
    Var => Exp::Var(<>),
    "undefined" => Exp::Undefined,
    "(" <Exp> ")",
};

Float: f64 = {
    // '2' or '2.'
    r"-?[0-9]+\.?" => f64::from_str(<>).unwrap(),
    // '.2' or '2.0'
    r"-?[0-9]*\.[0-9]+" => f64::from_str(<>).unwrap(),
    "NaN" => NAN
};

Var: String = {
    r"[A-Za-z_][0-9A-Za-z_]*" => String::from(<>)
};
