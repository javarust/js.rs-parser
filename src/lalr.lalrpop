use std::str::FromStr;
use std::f64::NAN;
use ast::{BinOp, Exp, Stmt};

grammar;

// Statement nonterminal
pub Stmt: Stmt = {
    SingleStmt,
    <s1:SingleStmt> <s2:Stmt> => Stmt::Seq(Box::new(s1), Box::new(s2)),
};

SingleStmt: Stmt = {
    <Var> "=" <Exp> ";" => Stmt::Assign(<>),
    "var" <Var> "=" <Exp> ";" => Stmt::Decl(<>),
    <Exp> ";" => Stmt::BareExp(<>),
    "while" <Clause> <Block> => Stmt::While(<>),
    "if" <Clause> <Block> <ElseIfBlock*> <ElseBlock?> => Stmt::If(<>),
};

ElseIfBlock: (Exp, Box<Stmt>) = {
    "else" "if" <Clause> <Block>,
};

ElseBlock: Box<Stmt> = {
    "else" <Block>,
};

Block: Box<Stmt> = {
    "{" <s:Stmt> "}" => Box::new(s),
};

Clause: Exp = {
    "(" <Exp> ")",
};

// Expression nonterminal
pub Exp: Exp = {
    OrExp,
};

OrExp = {
    <o:OrExp> "||" <a:AndExp> => Exp::BinExp(Box::new(o), BinOp::Or, Box::new(a)),
    AndExp,
};

AndExp = {
    <and:AndExp> "&&" <add:AddExp> => Exp::BinExp(Box::new(and), BinOp::And, Box::new(add)),
    AddExp,
};

// Parses addition and substraction
AddExp: Exp = {
    <a:AddExp> <o:AddOp> <m:MulExp> => Exp::BinExp(Box::new(a), o, Box::new(m)),
    MulExp,
};

AddOp: BinOp = {
    "+" => BinOp::Plus,
    "-" => BinOp::Minus,
};

// Parses multiplication and division
MulExp: Exp = {
    <m:MulExp> <o:MulOp> <e:PreExp> => Exp::BinExp(Box::new(m), o, Box::new(e)),
    PreExp,
};

MulOp: BinOp = {
    "*" => BinOp::Star,
    "/" => BinOp::Slash,
};

PreExp: Exp = {
    "++" <PreExp> => Exp::PreInc(Box::new(<>)),
    "--" <PreExp> => Exp::PreDec(Box::new(<>)),
    PostExp,
};

PostExp: Exp = {
    <PostExp> "++" => Exp::PostInc(Box::new(<>)),
    <PostExp> "--" => Exp::PostDec(Box::new(<>)),
    Term,
};

// Parses numbers and parenthetical expressions, and variables
Term: Exp = {
    Bool => Exp::Bool(<>),
    Float => Exp::Float(<>),
    Var => Exp::Var(<>),
    "undefined" => Exp::Undefined,
    "(" <Exp> ")",
    "-" <Term> => Exp::Neg(Box::new(<>)),
    "+" <Term> => Exp::Pos(Box::new(<>)),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

Float: f64 = {
    // '2' or '2.'
    r"-?[0-9]+\.?" => f64::from_str(<>).unwrap(),
    // '.2' or '2.0'
    r"-?[0-9]*\.[0-9]+" => f64::from_str(<>).unwrap(),
    "NaN" => NAN
};

Var: String = {
    r"[A-Za-z_][0-9A-Za-z_]*" => String::from(<>)
};
