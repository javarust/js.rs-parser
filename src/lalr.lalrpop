use std::str::FromStr;
use std::f64::NAN;
use jsrs_common::ast::{BinOp, Exp, Stmt};

grammar;

// Macros -----------------------------------------------------------------------------------------

ParenList<Val>: Vec<Val> = {
    "(" ")" => Vec::new(),
    "(" <p:ParenVal<Val>*> <v:Val> ")" => {
        let mut vec = p;
        vec.push(v);
        vec
    }
};

ParenVal<Val> = <Val> ",";

BinExp<Op, NextLevel>: Exp = {
    <b:BinExp<Op, NextLevel>> <o:Op> <n:NextLevel> => Exp::BinExp(Box::new(b), o, Box::new(n)),
    NextLevel,
};

// Statements -------------------------------------------------------------------------------------

pub Stmt: Stmt = {
    SingleStmt,
    <s1:SingleStmt> <s2:Stmt> => Stmt::Seq(Box::new(s1), Box::new(s2)),
    If,
};

SingleStmt: Stmt = {
    r#"/\*[A-Za-z0-9 `~!@#$%^&*()_+-=\[\]\{\}:;'"<>,\.?/]*\*/"# => Stmt::Empty,
    <Var> "=" <Exp> ";" => Stmt::Assign(<>),
    "var" <Var> "=" <Exp> ";" => Stmt::Decl(<>),
    <BareExp> ";" => Stmt::BareExp(<>),
    "return" <Exp> ";" => Stmt::Ret(<>),
    "while" <Clause> <Block> => Stmt::While(<>),
    NamedDefun => Stmt::BareExp(<>),
    "throw" <Exp> ";" => Stmt::Throw(Box::new(<>)),
    "if" <c:Clause> <b1:Block> "else" <b2:Block> => Stmt::If(c, b1, Some(b2)),
    "try" <t:BracedBlock> <c:CatchBlock> => Stmt::Try(t, Some(c), None),
    "try" <t:BracedBlock> <f:FinallyBlock> => Stmt::Try(t, None, Some(f)),
    "try" <t:BracedBlock> <c:CatchBlock> <f:FinallyBlock> => Stmt::Try(t, Some(c), Some(f)),
};

CatchBlock: Box<Stmt> = "catch" <BracedBlock>;
FinallyBlock: Box<Stmt> = "finally" <BracedBlock>;

If: Stmt = {
    "if" <c:Clause> <b:Block> => Stmt::If(c, b, None),
    "if" <c:Clause> <b:Block> "else" <i:If> => Stmt::If(c, b, Some(Box::new(i))),
};

Block: Box<Stmt> = {
    BracedBlock,
    SingleStmt => Box::new(<>),
};

BracedBlock: Box<Stmt> = "{" <s:Stmt> "}" => Box::new(s);
Clause = "(" <Exp> ")";

// Expressions ------------------------------------------------------------------------------------

pub Exp = {
    NonDefun,
    Defun,
};

BareExp = {
    NonDefun,
    NamedDefun,
};

Defun = {
    AnonDefun,
    NamedDefun,
};

AnonDefun: Exp = "function" <p:Params> <b:BracedBlock> => Exp::Defun(None, p, b);
NamedDefun: Exp = "function" <v:Var> <p:Params> <b:BracedBlock> => Exp::Defun(Some(v), p, b);
Params = ParenList<Var>;

NonDefun = OrExp;

OrExp = BinExp<OrOp, AndExp>;
OrOp: BinOp = "||" => BinOp::Or;

AndExp = BinExp<AndOp, EqExp>;
AndOp: BinOp = "&&" => BinOp::And;

EqExp = BinExp<EqOp, AddExp>;

EqOp: BinOp = {
    "==" => BinOp::Eql,
    "!=" => BinOp::Neq,
    ">" => BinOp::Gt,
    ">=" => BinOp::Ge,
    "<" => BinOp::Lt,
    "<=" => BinOp::Le,
};

AddExp = BinExp<AddOp, MulExp>;

AddOp: BinOp = {
    "+" => BinOp::Plus,
    "-" => BinOp::Minus,
};

MulExp = BinExp<MulOp, TypeOf>;

MulOp: BinOp = {
    "*" => BinOp::Star,
    "/" => BinOp::Slash,
};

TypeOf : Exp = {
    "typeof" <PreExp> => Exp::TypeOf(Box::new(<>)),
    PreExp,
};

PreExp: Exp = {
    "++" <PreExp> => Exp::PreInc(Box::new(<>)),
    "--" <PreExp> => Exp::PreDec(Box::new(<>)),
    PostExp,
};

PostExp: Exp = {
    <PostExp> "++" => Exp::PostInc(Box::new(<>)),
    <PostExp> "--" => Exp::PostDec(Box::new(<>)),
    SignedExp,
};

SignedExp: Exp = {
    "-" <SignedOperand> => Exp::Neg(Box::new(<>)),
    "+" <SignedOperand> => Exp::Pos(Box::new(<>)),
    SignedOperand,
};

SignedOperand = {
    Constructor,
    Call,
};

Constructor: Exp = {
    "new" <Constructor> => Exp::NewObject(Box::new(<>), Vec::new()),
    Term,
};

Call: Exp = {
    <c:Call> <a:Args> => Exp::Call(Box::new(c), a),
    <t:Term> <a:Args> => Exp::Call(Box::new(t), a),
    <c:Call> "." <v:Var> => Exp::InstanceVar(Box::new(c), v),
};

Term: Exp = {
    Lit,
    Var => Exp::Var(<>),
    "new" <t:Term> <a:Args> => Exp::NewObject(Box::new(t), a),
    "undefined" => Exp::Undefined,
    "(" <Exp> ")",
    <t:Term> "." <v:Var> => Exp::InstanceVar(Box::new(t), v),
};

Lit: Exp = {
    Bool => Exp::Bool(<>),
    Float => Exp::Float(<>),
    Str => Exp::Str(<>),
    "{" <ps:(<Property> ",")*> <p:Property?> "}" => {
        let v = match p {
            Some(prop) => {
                let mut ps = ps;
                ps.push(prop);
                ps
            },
            None => ps
        };

        Exp::Object(v)
    }
};

Property = {
    <Key> ":" <BoxExp>
};

Key = {
    Str,
    Var,
};

Args = ParenList<BoxExp>;
BoxExp: Box<Exp> = Exp => Box::new(<>);

Var: String = r"[A-Za-z_][0-9A-Za-z_]*" => String::from(<>);

// Literals ---------------------------------------------------------------------------------------

Bool: bool = {
    "true" => true,
    "false" => false,
};

Float: f64 = {
    // '2' or '2.'
    r"[-+]?[0-9]+\.?" => f64::from_str(<>).unwrap(),
    // '.2' or '2.0'
    r"[-+]?[0-9]*\.[0-9]+" => f64::from_str(<>).unwrap(),

    // '2' or '2.'
    r"[-+]?[0-9]+\.?[eE][-+]?[0-9]+" => f64::from_str(<>).unwrap(),
    // '.2' or '2.0'
    r"[-+]?[0-9]*\.[0-9]+[eE][-+]?[0-9]+" => f64::from_str(<>).unwrap(),
    "NaN" => NAN,
};

// Strings ----------------------------------------------------------------------------------------
Str = {
    SingleStr,
    DoubleStr,
};

SingleStr: String =
    r#"'(\\[0-3]?[0-7]{1,2}|[^\\']|\\[bfnrtv'"\\]|\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4})*'"# => String::from(&<>[1..<>.len()-1]);

DoubleStr: String =
    r#""(\\[0-3]?[0-7]{1,2}|[^\\"]|\\[bfnrtv'"\\]|\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4})*""# => String::from(&<>[1..<>.len()-1]);
