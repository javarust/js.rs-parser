use std::str::FromStr;
use std::f64::NAN;
use jsrs_common::ast::{BinOp, Exp, Stmt};

grammar;

// Macros -----------------------------------------------------------------------------------------

ParenList<Val>: Vec<Val> = {
    "(" ")" => Vec::new(),
    "(" <p:ParenVal<Val>*> <v:Val> ")" => {
        let mut vec = p;
        vec.push(v);
        vec
    }
};

ParenVal<Val> = <Val> ",";

BinExp<Op, NextLevel>: Exp = {
    <b:BinExp<Op, NextLevel>> <o:Op> <n:NextLevel> => Exp::BinExp(Box::new(b), o, Box::new(n)),
    NextLevel,
};

// Statements -------------------------------------------------------------------------------------

pub Stmt: Stmt = {
    SingleStmt,
    Defun => Stmt::BareExp(<>),
    <s1:SingleStmt> <s2:Stmt> => Stmt::Seq(Box::new(s1), Box::new(s2)),
};

SingleStmt: Stmt = {
    <Var> "=" <Exp> ";" => Stmt::Assign(<>),
    "var" <Var> "=" <Exp> ";" => Stmt::Decl(<>),
    <Exp> ";" => Stmt::BareExp(<>),
    "return" <Exp> ";" => Stmt::Ret(<>),
    "while" <Clause> <Block> => Stmt::While(<>),
    "if" <c:Clause> <b:Block> <vec:ElseIfBlock*> <els:ElseBlock?> => {
        let mut v = vec;

        match v.pop() {
            Some((e, s)) => {
                let mut elsif = Box::new(Stmt::If(e, s, els));

                for (e2, s2) in v.into_iter().rev() {
                    elsif = Box::new(Stmt::If(e2, s2, Some(elsif)));
                }

                Stmt::If(c, b, Some(elsif))
            }
            None => Stmt::If(c, b, els)
        }
    }
};

ElseIfBlock = "else" "if" <Clause> <Block>;
ElseBlock = "else" <Block>;

Block: Box<Stmt> = "{" <s:Stmt> "}" => Box::new(s);
Clause = "(" <Exp> ")";

// Expressions ------------------------------------------------------------------------------------

pub Exp = {
    NonDefun,
    Defun,
};

Defun: Exp = "function" <Var?> <Params> <Block> => Exp::Defun(<>);
Params = ParenList<Var>;

NonDefun = OrExp;

OrExp = BinExp<OrOp, AndExp>;
OrOp: BinOp = "||" => BinOp::Or;

AndExp = BinExp<AndOp, EqExp>;
AndOp: BinOp = "&&" => BinOp::And;

EqExp = BinExp<EqOp, AddExp>;

EqOp: BinOp = {
    "==" => BinOp::Eql,
    "!=" => BinOp::Neq,
    ">" => BinOp::Gt,
    ">=" => BinOp::Ge,
    "<" => BinOp::Lt,
    "<=" => BinOp::Le,
};

AddExp = BinExp<AddOp, MulExp>;

AddOp: BinOp = {
    "+" => BinOp::Plus,
    "-" => BinOp::Minus,
};

MulExp = BinExp<MulOp, PreExp>;

MulOp: BinOp = {
    "*" => BinOp::Star,
    "/" => BinOp::Slash,
};

PreExp: Exp = {
    "++" <PreExp> => Exp::PreInc(Box::new(<>)),
    "--" <PreExp> => Exp::PreDec(Box::new(<>)),
    PostExp,
};

PostExp: Exp = {
    <PostExp> "++" => Exp::PostInc(Box::new(<>)),
    <PostExp> "--" => Exp::PostDec(Box::new(<>)),
    SignedExp,
};

SignedExp: Exp = {
    "-" <Term> => Exp::Neg(Box::new(<>)),
    "+" <Term> => Exp::Pos(Box::new(<>)),
    Call,
};

Call: Exp = {
    <c:Call> <a:Args> => Exp::Call(Box::new(c), a),
    Term,
};

Term: Exp = {
    Bool => Exp::Bool(<>),
    Float => Exp::Float(<>),
    Var => Exp::Var(<>),
    "undefined" => Exp::Undefined,
    "(" <Exp> ")",
};

Args = ParenList<BoxExp>;
BoxExp: Box<Exp> = Exp => Box::new(<>);

Var: String = r"[A-Za-z_][0-9A-Za-z_]*" => String::from(<>);

// Literals ---------------------------------------------------------------------------------------

Bool: bool = {
    "true" => true,
    "false" => false,
};

Float: f64 = {
    // '2' or '2.'
    r"-?[0-9]+\.?" => f64::from_str(<>).unwrap(),
    // '.2' or '2.0'
    r"-?[0-9]*\.[0-9]+" => f64::from_str(<>).unwrap(),
    "NaN" => NAN
};
